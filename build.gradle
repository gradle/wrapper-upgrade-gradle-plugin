import org.gradle.util.GradleVersion

plugins {
    id 'groovy'
    id 'java-gradle-plugin'
    id 'maven-publish'
    id 'signing'
    id 'com.gradle.plugin-publish' version '1.2.0'
    id 'com.github.breadmoirai.github-release' version '2.4.1'
    id 'org.gradle.wrapper-upgrade' version '0.11.1'
}

def releaseVersion = releaseVersion()
def releaseNotes = releaseNotes()

group = 'org.gradle'
version = releaseVersion.get()
description = 'A Gradle plugin that detects and updates Gradle and Maven wrappers to the latest Gradle and Maven version.'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.kohsuke:github-api:1.314'
    implementation 'com.fasterxml.jackson.core:jackson-core:2.14.2'
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.15.0'

    testImplementation gradleTestKit()
    testImplementation 'org.spockframework:spock-core:2.3-groovy-3.0'
}

wrapperUpgrade {
    gradle {
        'wrapper-upgrade-gradle-plugin' {
            repo = 'gradle/wrapper-upgrade-gradle-plugin'
        }
    }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(8)
    }
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()

    def testGradleVersion = findProperty('testGradleVersion') ?: GradleVersion.current().version
    systemProperty 'testContext.gradleVersion', testGradleVersion
    buildScan.value(identityPath.path + "#gradleVersion", testGradleVersion)
}

gradlePlugin {
    website = "https://github.com/gradle/wrapper-upgrade-gradle-plugin/"
    vcsUrl = "https://github.com/gradle/wrapper-upgrade-gradle-plugin.git"

    automatedPublishing = true

    plugins {
        wrapperUpgrade {
            id = 'org.gradle.wrapper-upgrade'
            displayName = 'Wrapper Upgrade Gradle Plugin'
            description = releaseNotes.get()
            implementationClass = 'org.gradle.wrapperupgrade.WrapperUpgradePlugin'
            tags.addAll("gradle", "maven", "wrapper")
        }
    }
}

tasks.withType(ValidatePlugins).configureEach {
    failOnWarning = true
    enableStricterValidation = true
}

signing {
    // Require publications to be signed on CI. Otherwise, publication will be signed only if keys are provided.
    required providers.environmentVariable('CI').isPresent()

    useInMemoryPgpKeys(
        providers.environmentVariable('PGP_SIGNING_KEY').orNull,
        providers.environmentVariable('PGP_SIGNING_KEY_PASSPHRASE').orNull
    )
}

githubRelease {
    token = System.getenv('WRAPPER_UPGRADE_GRADLE_PLUGIN_GIT_TOKEN') ?: ''
    owner = 'gradle'
    repo = 'wrapper-upgrade-gradle-plugin'
    targetCommitish = 'main'
    releaseName = releaseVersion
    tagName = releaseVersion.map { "v$it" }
    prerelease = false
    overwrite = false
    generateReleaseNotes = false
    body = releaseNotes
}

def createReleaseTag = tasks.register('createReleaseTag', CreateGitTag) {
    // Ensure tag is created only after a successful publishing
    mustRunAfter('publishPlugins')
    tagName = githubRelease.tagName.map { it.toString() }
}

tasks.named('githubRelease') {
    dependsOn(createReleaseTag)
}

tasks.withType(com.gradle.publish.PublishTask).configureEach {
    notCompatibleWithConfigurationCache("$name task does not support configuration caching")
}

def releaseVersion() {
    def releaseVersionFile = layout.projectDirectory.file('release/version.txt')
    return providers.fileContents(releaseVersionFile).asText.map { it -> it.trim() }
}

def releaseNotes() {
    def releaseNotesFile = layout.projectDirectory.file('release/changes.md')
    return providers.fileContents(releaseNotesFile).asText.map { it -> it.trim() }
}
